#include<iostream>
#include"03-1（函数分文件编写）.h"
using namespace std;
	//5.0 函数
	//函数定义的步骤
	//返回值类型；函数名；参数数列；函数体语句；return表达式。
	//示例：加法函数
	/*int add(int a1, int a2)//此处的a1，a2是形参
	{
		int sum = a1 + a2;
		return sum;
	}*.//其他函数不能在main函数中
	//交换函数
	/*void swap(int a1, int a2)
	{
		cout << "交换前的情况为：num1=" << a1 << "\tnum2=" << a2 << endl;
		int temp = a1;
		a1 = a2;
		a2 = temp;
		cout << "交换后的情况为：num1=" << a1 << "\tnum2=" << a2 << endl;
		return;//返回值不需要的时候可以不写
	}*/

	//函数声明(类似于提前让编译器知道有这么个函数，具体函数在后面)

	//int max(int a1, int a2, int a3);//求取三个数字中的最大值
	//声明可以有多次，定义只能有一次

	int main() 
	{


	//5.1 函数调用（使用函数名）
	/*int m = add(5, 3);//此处的5，3是实参
					  //调用函数时，实参的值会传递给形参
	cout << m;*/

	//5.2 值传递(传递的是值而不是地址)
	/*//当我们做值传递时，函数形参发生变化，不会影响实参
	int num1 = 10, num2 = 20;
	cout << "初始值的情况为：num1=" << num1 << "\tnum2=" << num2 << endl;
	swap(num1, num2);
	cout << "此时值的情况为：num1=" << num1 << "\tnum2=" << num2;
	//值传递总结：
			//在值传递过程中，调用函数之后，函数中的形参变量会在内存中被分配到一个实际的内存空间，，用来存放变量值
			//而这个内存空间是不会和main函数中的实参内存空间发生冲突的（即各自有自己的内存空间）
			//因此，在被调用函数内部做一些值操作时，实际是对形参的内存空间进行的操作，并不会影响到实参的内存空间
			//但是，在之后涉及到指针式，就指向的是地址，而传入指针变量时，实际是传入了地址，与现在的情况可能发生不同
			//指针的情况应该会使用较多，因为如果实参没有发生改变，之后对于进行预期操作州的实参进行调用时可能会出现问题*/

	//5.3//函数的常见样式

		//无参无返；void test01（）{}――直接调用即可：test01（）；
		//有参无返；void test02（）{}――调用需要传入参数：test02（参数）；
		//无参有返；int  test03()  {return 返回值}――调用需要变量接收结果
		//有参有返。int  test04（参数）{return 返回值}――调用需要传入参数且需要变量接收结果

	//5.4 函数声明（告诉编译器函数名称以及如何调用函数）（函数主体可以单独进行定义）
		//函数声明可以多次，但是函数定义只能有一次
	/*int num1 = 5, num2 = 7,num3 = 9;
	int maxone=max(num1, num2, num3);
	cout << "maxone 为："<<maxone<<endl;*/


	//5.5 函数的分文件编写
		//具体步骤：
		//1.创建后缀为.h的文件（头文件）
		//2.创建后缀为.cpp的文件（源文件）
		//3.在头文件中写函数的声明
		//4.在源文件中写函数的定义

		//示例：交换函数
	int num1 = 10, num2 = 20;
	swap(num1,num2);
	cout << endl;

	system("pause");

	return 0;

}

	//max函数定义
	/*int max(int a1,int a2,int a3)
	{
		int temp = (a1>a2?a1:a2);
		return (temp > a3 ? temp : a3);
	}*/
