#include<iostream>
#include<string>
using namespace std;





int main()
{
	//4.1:数组
	//数组中的每一个数据都是同一类型的数据
	//数组由连续的内存组成
	//数组的三种定义方法：
	//法一：数据类型 数组名 【数组长度】
	/*int arr1[5];
	arr1[0] = 10;
	cout << arr1[0] << endl;*/
	//法二：数据类型 数组名 【数组长度】={值1，值2...}(初始化数据时未全部赋值时，会用0来填补)
	/*int arr2[5] = {0,1,2,3,4};
	for (int i = 0; i < 5; i++)
	{
		cout << arr2[i] << endl;
	}*/
	//法三：数据类型 数组名 【】={值1，值2...}
	/*int arr3[] = {0,1,2,3,4,5,6};//定义数组时必须有初始长度
	for (int i = 0; i < 7; i++)
	{
		cout << arr3[i] << endl;
	}*/
	//Tips：数组下标从0开始;数组起名尽量不和变量相同


	//4.1.1 一维数组数组名
	//用途：可以统计整个数组在内存中的长度（使用sizeof）；
	/*int arr4[] = {0,1,2,3,4,5,6,7,8,9};
	cout << "整个arr4数组所占内存空间为："<<sizeof(arr4) << endl
		<<"第四个元素所占内存空间为："<< sizeof(arr4[3]) << endl
		<<"整个数组内部的元素个数为："<<sizeof(arr4)/sizeof(arr4[0])<<endl;
	//可以获取数组在内存中的首地址（cout<<数组名<<endl）
	cout << "数组首地址为：" <<(int) arr4 << endl;//(int)-强制类型转换，转换为int类型
	cout << "数组中第一个元素地址为：" << (int)&arr4[0] << endl;//&为取地址符*/
	//Tips：数组名是一个常量，不可以进行赋值的操作

	//一维数组示例：五只小猪称体重，打印出所有小猪的体重，并且找出体重最大的小猪
	/*int arr5[5] = { 0,0,0,0,0 };
	int max = 0, seq = 0;
	int add = 0;
	for (int i = 0; i < 5; i++)
	{
		cout << "请输入第" << i + 1 << "只小猪的体重：" << endl;
		cin >> arr5[i];
		if (max < arr5[i])
		{
			max = arr5[i];
			seq = (i + 1);
		}//对于数组中最大值的寻找方法
		else if (max == arr5[i])
		{
			add = i + 1;
		}
	}
	if (add!=0&&arr5[add-1]==max)//判断条件要前后仔细考虑，注意每个变量代表的含义；
								 //主要是针对条件语句中的变量进行考虑：变量在过程中是否发生变化，这些变化是否对条件判断有影响
	{
		cout << "第" << add << "只小猪与第" << seq << "只小猪最重！" << endl
			<< "它们的体重都为：" << max << "公斤！！！\n";
	}
	else 
	{
		cout << "第" << seq << "只小猪最重！" << endl
			<< "它的体重为：" << max << "公斤！！！" << endl;
	}*/
	
	//数组元素逆置
	
	//分析(复杂方法，缺少思考)：
	/*//首先需要创建一个数组
	//如果利用原始数组进行逆置比较复杂，因此需要一个辅助数组
	int arr6[] = {0,1,2,3,4,5,6,7,8,9};
	//创建辅助数组，逆置过程需要知道数组原始长度
			//可以使用sizeof来求得数组长度，进而实现对于元素的逆置
			//需要三次赋值过程
	int length = sizeof(arr6) / sizeof(arr6[0]);
	cout << "数组长度为：" << length <<endl;
	cout << "原始数组为：";
	for (int k = 1; k <= length; k++)
	{
		 cout<< arr6[k - 1] << "\t";
	}//查错
	cout << endl;
	int arr7[] = {0,0,0,0,0,0,0,0,0,0};//创建临时数组
	for (int i = 1; i <=length; i++)
	{
		arr7[i - 1] = arr6[i-1];
	}//给临时数组赋值，两个数组序号需要保持相同
	cout << "临时数组为：";
	for (int n = 1; n <=length;n++)
	{
		cout << arr7[n - 1] << "\t";
	}//查错
	cout << endl;
	for (int j = 1; j<=length; j++)
	{
		arr6[j - 1] = arr7[length - j];
	}//利用临时数组进行逆置，两者序号相加需要等于length-1
	cout << "逆置后的数组为：";
	for (int m = 1; m <= length; m++)
	{
		cout << arr6[m - 1] <<"\t";
	}
	cout << endl;
	//使用临时数组必须要进行提前赋值，比较麻烦，应该考虑其他方法进行操作
					//你只过程其实很多时候都是两个数字之间的狡猾，可以设置一个临时变量而不用一个临时数组（有点类似于快速排序的思想）
	//条件判断语句，在数组中等号很多时候都是需要的
				//因为虽然实际长度比数组下标大1，但是如果没有等号，就会少一个元素，所以用-1，来消除这种不等的关系
				*/

	//法二（类快速排序）
	/*int arr8[15];
	int length = 15;
	cout << "请输入数组内的数据：（每个数之间利用空格进行区别）\n";
	for (int i = 1; i <= length; i++)
	{
		cin >>arr8[i-1];
	}
	int start=0, end=0;//start进行前序遍历，end进行后序遍历
					   //start和end是序号，而非存储空间，需要定义一个专门的变量用来临时存储元素值
	int temp;//临时变量存储元素值
	start = 0; end = (length - 1);//给start和end赋值，准备进行前序和后序遍历
								  //此时start指向第一个元素，end指向最后一个元素
	for (;start<end; )//注意循环条件
	{
		temp = arr8[start];//将第一个元素的值存放在temp中，此时就可以对第一个元素进行逆置
		arr8[start] = arr8[end];//将最后一个元素的值放在第一个元素中
		arr8[end] = temp;//将首元素的值放在最后一个元素中
		start++;//继续向后遍历
		end--;//继续向前遍历
	}
	cout<< "逆置后的元素为：" << endl;
	for (int j = 1; j<= length; j++)//for循环中每一个语句的书写都要仔细，初始值定义为1还是0需要考虑
	{
		cout<<arr8[j-1]<<"\t";
	}*/
	

	//4.1.2 冒泡排序
	/*//步骤：
		//1比较两个相邻的元素，如果第一个比第二个大就进行交换；
		//2.对每一对相邻元素都进行比较和交换，总共进行比较的轮数=元素数-1，每一轮比较的次数都比上一轮少一次；
		//3.当有一轮比较次数为0时，真个排序结束
	int arr10[] = {4,2,8,0,5,7,1,3,9 };//首先有用一个乱序数组，对它进行冒泡排序
	//首先有一个大循环，即为比较轮次的大循环，总共比较的轮次=数组元素个数-1
	//先确定比价轮次，即数组中元素个数
	int length=sizeof(arr10)/sizeof(arr10[0]);//球的数组中元素个数length
	//进行大的比较轮次的循环
	cout << "排序前的元素情况为：\n";
	for (int m = 1; m <= length; m++) { cout << arr10[m - 1] << "\t"; }
	cout << endl;
	for (int i = 1; i < length; i++)//对于循环中的语句进行审查，尤其是i的初始值以及条件判断语句
	{
		 //大的比较轮次循环中又嵌套一个每一趟的循环
				//每一趟的循环与i之间的关系为：每一趟比较次数=元素个数-i
					//可以设置一个比较计数器，使用if语句进行判读，同时定义一个抓门的比较函数
		for (int j=1; j <= (length-i); j++)//length时每一趟的比较次数，最多比较length-i次，所以次数应该有=
		{
			//设置一个相邻两数的比较交换函数
				//函数要求：相邻两数进行比较，大的后置，小的前置
			if (arr10[j-1]>arr10[j])//前大后小的条件下，进行呼唤操作
			{
				int temp = NULL;//临时变量，用于元素值互换
				temp = arr10[j];
				arr10[j] = arr10[j - 1];
				arr10[j - 1] = temp;//互换操作结束
			}
		}
	}
	cout << "排序后的元素情况为：\n";
	for (int n = 1; n <= length; n++) { cout << arr10[n - 1] << "\t"; }*/

	//4.2  二维数组
	//4.2.1 二维数组定义方式

	//定义方式
	//法一：数据类型 数组名【行数】【列数】；
	//int arr[4][6];//二维数组输出元素，可以使用嵌套循环进行访问，外层循环打印行数，内层循环打印列数
	//法二：数据类型 数组名【】【】={ {元素值,,,}
									//{元素值,,,}	
									//}；该定义方法可读性高，比较推荐
	//法三：数据类型 数组名【行数】【列数】={，，，，，，，，}；
	//法四：数据类型 数组名【】【列数】={,,,,,,}；
	//int arr[][2] = {1,2,3};//默认为2*2

	//4.2.1 二维数组名称
	
	/*//用途：查看二维数组所占内存空间；
	int arr[2][3] = { {1,2,3}, 
					  {4,5,6} };
	cout << "二位数组所占内存空间为："<< sizeof(arr)<<endl;
	cout << "二维数组第一行所占内存空间为：" << sizeof(arr[0]) << endl;
	//Tips：二五i数组元素个数求法：（总内存空间/单行所占内存）/单个元素所占内存
		//查看二维数组首地址
	cout << "二位数组首元素所在地址为：" <<(int) &arr[0][0] << endl;
	cout << "二位数组所在首地址为：" << (int)arr << endl;//可以利用数组名直接求出数组地址，不需要取地址符（获取某行或者某列地址也可以）
														 //只有在获取单个元素地址时才需要取地址符
	//上述两个首地址是相同的*/

	//二维数据示例：考试成绩统计
	/*//要求：已知三位同学各科成绩，要求算出总成绩
	//分析：可以创建一个3*3的二位数组进行成绩存放，之后可以利用循环对每一行元素之和进行计算
				//此处的循环可以利用for循环进行
	int arr[3][3] = {
					{60,70,80},
					{80,75,65},
					{75,85,60}//每个元素之间的逗号不能省略
	};
	//利用for函数进行求和
	//改进：(适当改进，使代码更人性化)
	string name[3] = {"张三","王五","李四"};
	for (int i = 0; i < 3; i++)//行循环
	{
		int sum = 0;//临时变量计算成绩总和
		for (int j = 0; j < 3; j++)
		{
			sum += arr[i][j];
		}
		cout << name[i] << "位同学的成绩为：" << sum << endl;//注意每个语句写的位置，循环嵌套时，结果输出的语句一般不会在最内层循环
															   //每一类别结果输出语句可能在两层循环之间，
															  //基于此类情况，结果输出要用得到的变量应该和结果输出语句位置相同
															  //小细节不能忽略，第i+1个同学
	}			
	//改进：添加一个名字数组*/

	cout << endl;

	system("pause");

	return 0;
}
